// --- State & Storage ---
const Views = { DAY: 'day', WEEK: 'week', MONTH: 'month' };

let currentView = Views.MONTH;
let currentDate = startOfDay(new Date());
let events = []; // { id, title, date, start?, end?, allDay?, color, desc? }

// Migrate old 'tasks' if present
(function migrateTasks(){
  const old = JSON.parse(localStorage.getItem('tasks') || '[]');
  const evs = JSON.parse(localStorage.getItem('events') || '[]');
  if (old.length && !evs.length) {
    const migrated = old.map(t => ({
      id: cryptoRandomId(),
      title: t.text || 'Task',
      date: t.date || fmtISODate(new Date()),
      allDay: true,
      color: '#1a73e8'
    }));
    localStorage.setItem('events', JSON.stringify(migrated));
  }
})();

// Load events
events = JSON.parse(localStorage.getItem('events') || '[]');

// --- Elements ---
const headerLabel = document.getElementById('currentLabel');
const grid = document.getElementById('calendarGrid');
const header = document.getElementById('calendarHeader');

const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const todayBtn = document.getElementById('todayBtn');
const viewBtns = document.querySelectorAll('.view-btn');
const jumpToDate = document.getElementById('jumpToDate');
const miniMonth = document.getElementById('miniMonth');

const eventDialog = document.getElementById('eventDialog');
const openEventForm = document.getElementById('openEventForm');
const closeDialogBtn = document.getElementById('closeDialog');
const deleteEventBtn = document.getElementById('deleteEvent');
const saveEventBtn = document.getElementById('saveEvent');

const evId = document.getElementById('evId');
const evTitle = document.getElementById('evTitle');
const evDate = document.getElementById('evDate');
const evAllDay = document.getElementById('evAllDay');
const evStart = document.getElementById('evStart');
const evEnd = document.getElementById('evEnd');
const evColor = document.getElementById('evColor');
const evDesc = document.getElementById('evDesc');

// --- Init ---
document.addEventListener('DOMContentLoaded', () => {
  jumpToDate.value = fmtISODate(currentDate);
  miniMonth.value = fmtISOMonth(currentDate);
  updateViewButtons();
  render();

  prevBtn.addEventListener('click', () => { shiftPeriod(-1); });
  nextBtn.addEventListener('click', () => { shiftPeriod(1); });
  todayBtn.addEventListener('click', () => { currentDate = startOfDay(new Date()); render(); });

  viewBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      currentView = btn.dataset.view;
      updateViewButtons();
      render();
    });
  });

  jumpToDate.addEventListener('change', () => {
    if (jumpToDate.value) {
      currentDate = new Date(jumpToDate.value + 'T00:00:00');
      render();
    }
  });

  miniMonth.addEventListener('change', () => {
    if (miniMonth.value) {
      const [y, m] = miniMonth.value.split('-').map(Number);
      currentDate = new Date(y, m - 1, 1);
      currentView = Views.MONTH;
      updateViewButtons();
      render();
    }
  });

  openEventForm.addEventListener('click', () => openEventDialog());
  closeDialogBtn.addEventListener('click', () => eventDialog.close());
  saveEventBtn.addEventListener('click', saveEventFromForm);
  deleteEventBtn.addEventListener('click', deleteEventFromForm);
  evAllDay.addEventListener('change', () => {
    document.getElementById('timeRow').style.display = evAllDay.checked ? 'none' : 'grid';
  });
});

function updateViewButtons(){
  document.querySelectorAll('.view-btn').forEach(b => b.classList.toggle('active', b.dataset.view === currentView));
}

// --- Rendering ---
function render(){
  header.innerHTML = '';
  grid.innerHTML = '';

  if (currentView === Views.MONTH) {
    renderMonth();
  } else if (currentView === Views.WEEK) {
    renderWeek();
  } else {
    renderDay();
  }
  headerLabel.textContent = labelForCurrentPeriod();
}

// Month View
function renderMonth(){
  const dows = daysOfWeek();
  header.style.gridTemplateColumns = `repeat(7, 1fr)`;
  grid.className = 'calendar-grid';
  grid.style.gridTemplateColumns = `repeat(7, 1fr)`;

  dows.forEach(d => {
    const el = document.createElement('div');
    el.className = 'dow';
    el.textContent = d;
    header.appendChild(el);
  });

  const first = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
  const start = startOfWeek(first);
  const last = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);
  const end = endOfWeek(last);
  const days = eachDay(start, end);

  const tpl = document.getElementById('monthCellTpl');

  days.forEach(day => {
    const cell = tpl.content.firstElementChild.cloneNode(true);
    const dayNum = cell.querySelector('.day-number');
    const evs = cell.querySelector('.events');

    dayNum.textContent = day.getDate();
    if (day.getMonth() !== currentDate.getMonth()) cell.style.opacity = 0.5;
    cell.addEventListener('dblclick', () => openEventDialog({ date: fmtISODate(day) }));

    listEventsForDate(day).forEach(e => {
      const chip = document.getElementById('eventChipTpl').content.firstElementChild.cloneNode(true);
      chip.textContent = e.allDay ? e.title : `${e.title} â€¢ ${e.start}`;
      chip.style.background = hexWithAlpha(e.color, 0.12);
      chip.style.borderLeftColor = e.color;
      chip.title = e.desc || '';
      chip.addEventListener('click', () => openEventDialog(e));
      evs.appendChild(chip);
    });

    grid.appendChild(cell);
  });
}

// Week View
function renderWeek(){
  const start = startOfWeek(currentDate);
  const days = Array.from({length:7}, (_,i)=> addDays(start, i));

  header.style.gridTemplateColumns = `60px repeat(7, 1fr)`;
  header.innerHTML = '';
  const empty = document.createElement('div');
  empty.className = 'hours-col';
  header.appendChild(empty);
  days.forEach(d => {
    const el = document.createElement('div');
    el.className = 'dow';
    el.textContent = formatDowHeader(d);
    header.appendChild(el);
  });

  const tg = document.createElement('div');
  tg.className = 'time-grid';
  grid.appendChild(tg);

  for (let h=0; h<24; h++){
    const lbl = document.createElement('div');
    lbl.className = 'hour-label';
    lbl.textContent = hourLabel(h);
    tg.appendChild(lbl);
  }
  for (let c=0;c<7;c++){
    for (let h=0; h<24; h++){
      const cell = document.createElement('div');
      cell.className = 'hour-cell';
      cell.dataset.dayIndex = c;
      cell.dataset.hour = h;
      const date = fmtISODate(days[c]);
      cell.addEventListener('dblclick', () => openEventDialog({
        date,
        start: `${String(h).padStart(2,'0')}:00`,
        end: `${String((h+1)%24).padStart(2,'0')}:00`,
        allDay: false,
      }));
      tg.appendChild(cell);
    }
  }

  // Layout timed events with overlaps
  days.forEach((d, dayIdx) => {
    const evs = listEventsForDate(d).filter(e=>!e.allDay);
    const laid = layoutDayEvents(evs);
    laid.forEach(e => {
      const block = buildEventBlock(e);
      positionEventInTimeGrid(block, tg, dayIdx, e.startHour, e.durationH, false, e.colIndex, e.colCount);
      tg.appendChild(block);
    });
    // all-day as chips
    listEventsForDate(d).filter(e=>e.allDay).forEach(e => {
      const block = buildEventBlock(e);
      positionEventInTimeGrid(block, tg, dayIdx, 0, 0.5, true, 0, 1);
      tg.appendChild(block);
    });
  });
}

// Day View
function renderDay(){
  const d = currentDate;
  header.style.gridTemplateColumns = `60px 1fr`;
  header.innerHTML = '';
  const empty = document.createElement('div');
  empty.className = 'hours-col';
  header.appendChild(empty);
  const el = document.createElement('div');
  el.className = 'dow';
  el.textContent = formatDowHeader(d);
  header.appendChild(el);

  const tg = document.createElement('div');
  tg.className = 'time-grid day';
  grid.appendChild(tg);

  for (let h=0; h<24; h++){
    const lbl = document.createElement('div');
    lbl.className = 'hour-label';
    lbl.textContent = hourLabel(h);
    tg.appendChild(lbl);
  }
  for (let h=0; h<24; h++){
    const cell = document.createElement('div');
    cell.className = 'hour-cell';
    cell.dataset.hour = h;
    cell.addEventListener('dblclick', () => openEventDialog({
      date: fmtISODate(d),
      start: `${String(h).padStart(2,'0')}:00`,
      end: `${String((h+1)%24).padStart(2,'0')}:00`,
      allDay: false,
    }));
    tg.appendChild(cell);
  }

  const evs = listEventsForDate(d);
  const timed = evs.filter(e=>!e.allDay);
  const laid = layoutDayEvents(timed);
  laid.forEach(e => {
    const block = buildEventBlock(e);
    positionEventInTimeGrid(block, tg, 0, e.startHour, e.durationH, false, e.colIndex, e.colCount);
    tg.appendChild(block);
  });
  evs.filter(e=>e.allDay).forEach(e => {
    const block = buildEventBlock(e);
    positionEventInTimeGrid(block, tg, 0, 0, 0.5, true, 0, 1);
    tg.appendChild(block);
  });
}

// Layout overlapping events (timed)
function layoutDayEvents(evs){
  evs.forEach(e => {
    const [sh, sm] = (e.start||'00:00').split(':').map(Number);
    const [eh, em] = (e.end||'00:00').split(':').map(Number);
    e.startMin = sh*60+sm;
    e.endMin = eh*60+em;
    e.startHour = e.startMin/60;
    e.durationH = Math.max(0.25,(e.endMin - e.startMin)/60);
  });
  evs.sort((a,b)=>a.startMin-b.startMin || b.endMin-a.endMin);
  const results = [];
  let groups = [];
  evs.forEach(ev => {
    let placed = false;
    for (let g of groups){
      if (ev.startMin >= g.maxEnd){
        g.events.push(ev);
        g.maxEnd = Math.max(g.maxEnd, ev.endMin);
        placed = true;
        break;
      }
    }
    if (!placed){
      groups.push({ events:[ev], maxEnd: ev.endMin });
    }
  });
  groups.forEach(g => {
    const cols = [];
    g.events.forEach(ev => {
      let col=0;
      while (cols[col] && cols[col]>ev.startMin) col++;
      ev.colIndex = col;
      cols[col] = ev.endMin;
    });
    const colCount = cols.length;
    g.events.forEach(ev => { ev.colCount = colCount; results.push(ev); });
  });
  return results;
}

function positionEventInTimeGrid(block, tg, dayIndex, startHourFloat, durationHours, isAllDay, colIndex, colCount){
  const labelsColWidth = 60;
  const totalCols = tg.classList.contains('day') ? 1 : 7;
  const colWidth = (tg.clientWidth - labelsColWidth) / totalCols;
  const top = startHourFloat * 48;
  const height = isAllDay ? 24 : Math.max(24, durationHours * 48);
  const dayLeft = labelsColWidth + dayIndex * colWidth;
  const widthPerCol = (colWidth - 8) / (colCount || 1);
  const left = dayLeft + 4 + (colIndex||0) * widthPerCol;
  block.style.top = `${top}px`;
  block.style.height = `${height}px`;
  block.style.left = `${left}px`;
  block.style.width = `${widthPerCol - 4}px`;
}

function buildEventBlock(e){
  const el = document.createElement('div');
  el.className = 'event-block';
  el.style.background = e.color || '#1a73e8';
  const timeText = e.allDay ? 'All day' : `${e.start}â€“${e.end}`;
  el.innerHTML = `<div class="title">${escapeHtml(e.title)}</div><div class="time">${timeText}</div>`;
  el.title = e.desc || '';
  el.addEventListener('click', (evt) => { evt.stopPropagation(); openEventDialog(e); });
  return el;
}

// --- Event dialog ---
function openEventDialog(prefill = {}){
  evId.value = prefill.id || '';
  evTitle.value = prefill.title || '';
  evDate.value = prefill.date || fmtISODate(currentDate);
  evAllDay.checked = prefill.allDay ?? false;
  evStart.value = prefill.start || '09:00';
  evEnd.value = prefill.end || '10:00';
  evColor.value = prefill.color || '#1a73e8';
  evDesc.value = prefill.desc || '';
  document.getElementById('dialogTitle').textContent = prefill.id ? 'Edit event' : 'Create event';
  deleteEventBtn.hidden = !prefill.id;
  document.getElementById('timeRow').style.display = evAllDay.checked ? 'none' : 'grid';
  if (!eventDialog.open) eventDialog.showModal();
}

function saveEventFromForm(){
  const id = evId.value || cryptoRandomId();
  const payload = {
    id,
    title: evTitle.value.trim(),
    date: evDate.value,
    allDay: evAllDay.checked,
    start: evAllDay.checked ? undefined : evStart.value,
    end: evAllDay.checked ? undefined : evEnd.value,
    color: evColor.value,
    desc: evDesc.value.trim()
  };
  if (!payload.title || !payload.date) return;

  const idx = events.findIndex(e => e.id === id);
  if (idx >= 0) events[idx] = payload; else events.push(payload);
  persistEvents();
  eventDialog.close();
  currentDate = new Date(payload.date + 'T00:00:00');
  jumpToDate.value = fmtISODate(currentDate);
  miniMonth.value = fmtISOMonth(currentDate);
  render();
}

function deleteEventFromForm(){
  const id = evId.value;
  events = events.filter(e => e.id !== id);
  persistEvents();
  eventDialog.close();
  render();
}

function persistEvents(){
  localStorage.setItem('events', JSON.stringify(events));
}

// --- Helpers ---
function shiftPeriod(delta){
  if (currentView === Views.MONTH){
    currentDate = addMonths(currentDate, delta);
  } else if (currentView === Views.WEEK){
    currentDate = addDays(currentDate, delta * 7);
  } else {
    currentDate = addDays(currentDate, delta);
  }
  jumpToDate.value = fmtISODate(currentDate);
  miniMonth.value = fmtISOMonth(currentDate);
  render();
}

function labelForCurrentPeriod(){
  const fmt = (d) => d.toLocaleDateString(undefined, { month:'long', year:'numeric' });
  if (currentView === Views.MONTH) return fmt(currentDate);
  if (currentView === Views.WEEK){
    const s = startOfWeek(currentDate);
    const e = addDays(s,6);
    const sameMonth = s.getMonth() === e.getMonth() && s.getFullYear() === e.getFullYear();
    const left = s.toLocaleDateString(undefined, { month:'short', day:'numeric' });
    const right = e.toLocaleDateString(undefined, sameMonth ? { day:'numeric' } : { month:'short', day:'numeric' });
    return `${left} â€“ ${right}`;
  }
  return currentDate.toLocaleDateString(undefined, { weekday:'long', month:'long', day:'numeric', year:'numeric' });
}

function daysOfWeek(){
  const base = startOfWeek(new Date(2023,0,1));
  return Array.from({length:7}, (_,i)=> addDays(base,i).toLocaleDateString(undefined, { weekday:'short'}));
}

function formatDowHeader(d){
  const wd = d.toLocaleDateString(undefined, { weekday:'short' });
  const md = d.toLocaleDateString(undefined, { month:'short', day:'numeric' });
  return `${wd} ${md}`;
}

function listEventsForDate(date){
  const iso = fmtISODate(date);
  return events.filter(e => e.date === iso);
}

function eachDay(start, end){
  const arr = []; let d = new Date(start);
  while (d <= end) { arr.push(new Date(d)); d.setDate(d.getDate()+1); }
  return arr;
}
function startOfDay(d){ const x = new Date(d); x.setHours(0,0,0,0); return x; }
function addDays(d, n){ const x = new Date(d); x.setDate(x.getDate()+n); return x; }
function addMonths(d,n){ const x = new Date(d); x.setMonth(x.getMonth()+n); return x; }
function startOfWeek(d){ const x = new Date(d); const day = x.getDay(); const diff = day===0?-6:1-day; x.setDate(x.getDate()+diff); x.setHours(0,0,0,0); return x; }
function endOfWeek(d){ return addDays(startOfWeek(d),6); }
function fmtISODate(d){ return d.toISOString().slice(0,10); }
function fmtISOMonth(d){ return d.toISOString().slice(0,7); }
function hourLabel(h){ return `${h}:00`; }
function hexWithAlpha(hex, alpha){
  const bigint = parseInt(hex.slice(1), 16);
  const r = (bigint >> 16) & 255, g = (bigint >> 8) & 255, b = bigint & 255;
  return `rgba(${r},${g},${b},${alpha})`;
}
function cryptoRandomId(){ return Math.random().toString(36).substr(2,9); }
function escapeHtml(str){ return str.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
